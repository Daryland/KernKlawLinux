/* file_watch.bpf.c — eBPF program: watch file open/write events
 *
 * Compiled with:
 *   clang -O2 -g -target bpf -D__TARGET_ARCH_x86 \
 *         -I/usr/include/bpf \
 *         -c file_watch.bpf.c -o file_watch.bpf.o
 *
 * Attached to:
 *   tracepoint/syscalls/sys_enter_openat
 *   tracepoint/syscalls/sys_enter_write
 *
 * Events are pushed to userspace via BPF ring-buffer map "events".
 * The struct layout MUST match claw_ebpf_event_t in ebpf_hooks.h.
 */
#include "vmlinux.h"             /* generated by bpftool btf dump */
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

/* ── Keep in sync with src/daemon/ebpf_hooks.h ─────────────────────── */
#define CLAW_EVENT_FILE_OPEN  1
#define CLAW_EVENT_FILE_WRITE 2
#define CLAW_EVENT_NET_CONN   3
#define CLAW_EVENT_PROC_EXEC  4
#define CLAW_EVENT_PROC_EXIT  5

struct claw_event {
    __u32  pid;
    __u32  uid;
    __s32  type;
    char   comm[16];
    char   path[256];
    __s64  ts_ns;
};

/* ── Ring-buffer map ─────────────────────────────────────────────── */
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);  /* 256 KiB ring */
} events SEC(".maps");

/* ── Filter: only emit for non-root processes ─────────────────────── */
static __always_inline int should_trace(void)
{
    __u32 uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
    /* Skip kernel threads (uid=0 comm=kworker etc.) — keep for all users */
    return 1;
}

/* ── tracepoint: sys_enter_openat ─────────────────────────────────── */
SEC("tracepoint/syscalls/sys_enter_openat")
int tp_openat(struct trace_event_raw_sys_enter *ctx)
{
    if (!should_trace()) return 0;

    struct claw_event *ev = bpf_ringbuf_reserve(&events, sizeof(*ev), 0);
    if (!ev) return 0;

    ev->pid    = bpf_get_current_pid_tgid() >> 32;
    ev->uid    = bpf_get_current_uid_gid() & 0xFFFFFFFF;
    ev->type   = CLAW_EVENT_FILE_OPEN;
    ev->ts_ns  = bpf_ktime_get_ns();
    bpf_get_current_comm(ev->comm, sizeof(ev->comm));

    /* ctx->args[1] = filename (const char __user *) */
    const char *filename = (const char *)ctx->args[1];
    bpf_probe_read_user_str(ev->path, sizeof(ev->path), filename);

    bpf_ringbuf_submit(ev, 0);
    return 0;
}

/* ── tracepoint: sys_enter_write ──────────────────────────────────── */
SEC("tracepoint/syscalls/sys_enter_write")
int tp_write(struct trace_event_raw_sys_enter *ctx)
{
    if (!should_trace()) return 0;

    /* Only trace writes to fd >= 3 (skip stdin/stdout/stderr) */
    int fd = (int)ctx->args[0];
    if (fd < 3) return 0;

    struct claw_event *ev = bpf_ringbuf_reserve(&events, sizeof(*ev), 0);
    if (!ev) return 0;

    ev->pid   = bpf_get_current_pid_tgid() >> 32;
    ev->uid   = bpf_get_current_uid_gid() & 0xFFFFFFFF;
    ev->type  = CLAW_EVENT_FILE_WRITE;
    ev->ts_ns = bpf_ktime_get_ns();
    bpf_get_current_comm(ev->comm, sizeof(ev->comm));

    /* We don't have the filename here (only fd); store fd in path field */
    __builtin_snprintf(ev->path, sizeof(ev->path), "fd=%d", fd);

    bpf_ringbuf_submit(ev, 0);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
